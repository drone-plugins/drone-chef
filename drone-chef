#!/usr/bin/env ruby

require 'json'
require 'pathname'
require 'chef/cookbook/metadata'
require 'fileutils'

#
# Parse build data JSON string
#
def build_data
  @build_data ||= JSON.parse ARGV[1]
end

#
# Path to project workspace
#
def workspace
  build_data['workspace']['path']
end

#
# Grab build args from build_data
#
def build_args
  build_data['vargs']
end

#
# Cookbook metadata
#
def cookbook
  @metadata ||= begin
    metadata = Chef::Cookbook::Metadata.new
    metadata.from_file("#{workspace}/metadata.rb")
    metadata
  end
end

#
# Wether or not to freeze the cookbook version during upload
#
def freeze
  @freeze ||= begin
    return true if build_args['freeze'].nil?
    build_args['freeze']
  end
end

def recursive
  @recursive ||= begin
    return true if build_args['recursive'].nil?
    build_args['recursive']
  end
end

def verify_reqs_server
  fail 'Chef organization required' unless build_args.key? 'org'
end

#
# Verify required build arguments
#
def verify_reqs # rubocop:disable AbcSize
  puts 'Verifying required arguments'
  fail 'No build data found' if ARGV[1].nil?
  fail 'Username required' unless build_args.key? 'user'
  fail 'Key required' unless build_args.key? 'key'
  fail 'Server URL required' unless build_args.key? 'server'
  verify_reqs_server if upload_to == 'server'
end

#
# The knife command to show details on a cookbook based on upload_to
#
def knife_show
  # return 'knife cookbook show' if upload_to == 'server'
  'knife supermarket show'
end

#
# Is cookbook already uploaded at given version?
#
def cookbook_uploaded? # rubocop:disable AbcSize
  puts "Checking if #{cookbook.name}@#{cookbook.version} " \
       "is already uploaded to #{chef_url}"

  command = ["#{knife_show} #{cookbook.name} #{cookbook.version}"]
  command << "-c #{knife_rb}"
  `#{command.join(' ')}`

  puts "Cookbook #{cookbook.name} version #{cookbook.version} " \
       "already uploaded to #{chef_url}" if $?.success? # rubocop:disable SpecialGlobalVars, LineLength

  $?.success? # rubocop:disable SpecialGlobalVars
end

#
# Chef URL based off Chef Server and Org
#
def chef_url
  "#{build_args['server']}/organizations/#{build_args['org']}"
end

def key_path
  '/tmp/key.pem'
end

#
# Write string encoded RSA key to a temporary file
#
def write_key
  puts 'Writing temp key'
  File.open(key_path, 'w') do |f|
    f.write build_args['key']
  end
end

#
# Knife.rb path
#
def knife_rb
  "#{Dir.home}/.chef/knife.rb"
end

#
# SSL mode when when connecting to chef server
#
def ssl_verify_mode
  return ':verify_peer' unless build_args.key? 'ssl_verify_mode'
  build_args['ssl_verify_mode'] ? ':verify_peer' : ':verify_none'
end

#
# Write knife.rb config
#
def write_knife_rb # rubocop:disable AbcSize
  FileUtils.mkdir_p File.dirname knife_rb
  File.open(knife_rb, 'w') do |f|
    f.puts "node_name '#{build_args['user']}'"
    f.puts "client_key '#{key_path}'"
    f.puts "chef_server_url '#{chef_url}'"
    f.puts "cookbook_path '#{Pathname.new(workspace).parent}'"
    f.puts "ssl_verify_mode #{ssl_verify_mode}"
    f.puts "knife[:supermarket_site] = '#{build_args['server']}'"
  end
end

#
# What we are uploading to
#   * server
#   * supermarket
#
def upload_to
  return 'supermarket' unless build_args.key? 'type'
  build_args['type']
end

#
# What we are uploading from
#   * cookbook
#   * org
#
def upload_from
  return 'cookbook' if File.exist? 'metadata.rb'
  'org'
end

def upload_message
  if upload_from == 'cookbook'
    puts "Uploading cookbook #{cookbook.name}@#{cookbook.version}"
  end
  puts 'Uploading cookbooks' if upload_from == 'org'
end

#
# Upload the cookbook
#
def upload_cookbook
  upload_message

  case upload_to
  when 'supermarket'
    upload_cookbook_supermarket
  when 'server'
    upload_cookbook_server
  else
    fail "No logic to upload cookbooks to type '#{upload_to}'."
  end
end

#
# Command to generate Berkshelf lockfile
#
def berks_install
  puts 'Generating Berksfile.lock'
  `berks install -b #{workspace}/Berksfile` unless File.exist? 'Berksfile.lock'
  fail 'Failed to generate berks lockfile' unless $?.success? # rubocop:disable SpecialGlobalVars, LineLength
end

#
# Command to upload cookbook(s) with Berkshelf
#
def berks_upload # rubocop:disable AbcSize
  puts 'Running berks upload'
  command = ['berks upload']
  command << "#{cookbook.name}" unless recursive
  command << "-b #{workspace}/Berksfile"
  command << "-c #{knife_rb}"
  command << '--no-no-freeze' if freeze
  puts `#{command.join(' ')}`
  fail 'Failed to upload cookbook' unless $?.success? # rubocop:disable SpecialGlobalVars, LineLength
end

#
# Upload cookbook(s) to a Chef Server
#
def upload_cookbook_server
  berks_install
  berks_upload
end

#
# Upload cookbook to Supermarket
#
def upload_cookbook_supermarket
  command = ["knife supermarket share #{cookbook.name}"]
  command << "-c #{knife_rb}"
  puts `#{command.join(' ')}`
  fail 'Failed to upload cookbook' unless $?.success? # rubocop:disable SpecialGlobalVars, LineLength
end

def write_netrc
  File.open("#{Dir.home}/.netrc", 'w') do |f|
    f.puts "machine #{build_data['workspace']['netrc']['machine']}"
    f.puts "  login #{build_data['workspace']['netrc']['login']}"
    f.puts "  password #{build_data['workspace']['netrc']['password']}"
  end
end

######
# MAIN
######
write_netrc
verify_reqs
write_key
write_knife_rb
exit if upload_to == 'supermarket' && cookbook_uploaded?
upload_cookbook
